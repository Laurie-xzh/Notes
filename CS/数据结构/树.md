#data-structure #tree
# 基本定义
一类非线性数据结构，以分支关系定义的层次结构

树是n(n>0)个结点的有限点集$T$，其中
- 有且仅有一个特定的结点，称为树的根（root）
- 当n>1的时候，其余结点可以分为m(m>0)个互不相交的有限集T1, T2, ... Tm，其中每一个集合本身又是一棵树，称为根的子树

特点
- 树中至少有一个结点——根，它有后继而无前驱
- 树中各子树是互不相交的集合

树的表示方法：
- 倒悬树
- 嵌套集合
- 广义表形式
- 凹入法形式

基本术语
- 结点(node)——表示树中的元素，包括数据项及若干指向其子树的分支
- 结点的度(degree)——结点拥有的<font color="#ff0000">子树数</font> 
- 叶子(leaf)——度为0的结点
- 孩子(child)——结点子树的根称为该结点的孩子
- 双亲(parents)——孩子结点的上层结点叫该结点的~
- 兄弟(sibling)——同一双亲的孩子
- 树的度——一棵树中<font color="#ff0000">最大的结点度数</font>
- 结点的层次(level)——从根结点算起，根为第一层，它的孩子为第二层……
- 深度(depth)——树中结点的最大层次数
- 森林(forest)——m(m0)棵互不相交的树的集合
 
 示例![[Pasted image 20230506153639.png]]

树的基本运算
- 初始化树
- 求树的根
- 求树中某个结点的双亲结点
- 求树中某个结点的孩子结点
- 树的遍历
- 树的删除

# 树的存储结构

1. 双亲表示法
	实现：定义结构数组存放树的结点，每个结点含两个域：
	- 数据域：存放结点本身信息
	- 双亲域：指示本结点的双亲结点在数组中位置
	特点：找双亲容易，找孩子难
 ```c
typedef struct node 
{ 
	datatype data;
	int parent; 
}JD;

JD t[M];
 ```

示例
![[Pasted image 20230506160817.png]]


 2. 孩子表示法
	多重链表：每个结点有多个指针域，分别指向其子树的根
	- 结点同构：结点的指针个数相等，为树的度D
	- 结点不同构：结点指针个数不等，为该结点的度d
	   如图，第一行是同构的结点，第二行是不同构的结点![[Pasted image 20230506160934.png]]
	   
	孩子链表：每个结点的孩子结点用单链表存储，再用含n个元素的结构数组指向每个孩子链表
	特点：找孩子容易，找双亲难
```c
// child node
typedef struct node
{ int child; //该结点在表头数组中下标
struct node *next; //指向下一孩子结点
}JD;

// head node
typedef struct tnode
{ datatype data; //数据域
struct node *fc; //指向第一个孩子结点
}TD;

TD t[M]; //t[0]不用
```

示例![[Pasted image 20230506161712.png]]
上图中，表头元素下标为0的单元置空


3. 带双亲的孩子链表表示法（双亲孩子易找）
	在孩子链表的表头中加入用于描述结点双亲位置的信息

![[Pasted image 20230506161414.png]]

4. 孩子兄弟表示法
	优点：易于树的各种运算
	缺点：破坏了树的层次关系

# 几种重要的树
[[二叉树]]

[[哈夫曼树]]

[[B+树]]

[[红黑树]]

# 树的遍历
遍历——按一定规律走遍树的各个顶点，且使每一顶点仅被访问一次，即找一个完整而有规律的走法，以得到树中所有结点的一个线性排列

常用方法
- 先根（序）遍历：先访问树的根结点，然后依次先根遍历根的每棵子树
- 后根（序）遍历：先依次后根遍历每棵子树，然后访问根结点
- 按层次遍历：先访问第一层上的结点，然后依次遍历第二层， ……第n层的结点


森林：可以分解成三部分 -> 1. 森林中第一棵树的根结点；2. 森林中第一棵树的子树森林；3. 森林中其它树构成的森林。

**森林的遍历**
- 先序遍历
- 中序遍历
- 后序遍历

# 转换

## 树与二叉树
![[Pasted image 20230609223208.png]]
![[Pasted image 20230609223248.png]]

## 森林与二叉树
![[Pasted image 20230609223330.png]]
![[Pasted image 20230609223341.png]]
